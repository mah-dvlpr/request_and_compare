#!/bin/bash

# Example usage:
# ./request_and_compare path/to/file [path/to/file2...]

# The file that you provide should have the structure
# NAME OF THE TEST
# ################################
# THE REQUEST SENT TO SERVER
# ################################
# HEADERS TO IGNORE IN RESPONSE
# ################################
# THE EXPECTED RESPONSE
# ################################

# Here is an example of what the file might look like:
# GET
# ################################
# GET / HTTP/1.1
# Host: localhost:8080
# Connection: close
#
# ################################
# Date
# Last-Modified
# ETag
# ################################
# HTTP/1.1 200 OK
# Content-Type: text/html
# Accept-Ranges: bytes
# #IGNORED -> ETag#
# #IGNORED -> Last-Modified#
# Content-Length: 93
# Connection: close
# #IGNORED -> Date#
# Server: lighttpd/1.4.55

# <html>
#     <body>
#         <h1>
#             Index test page!
#         </h1>
#     </body>
# </html>

# ################################

DELIM="################################"
COLOR_RESET="\033[0m"
COLOR_GREEN="\033[1;92m"
COLOR_RED="\033[1;91m"

# Print the current segment of the input file, without any string interpretation.
get_current_segment() {
    printf "${1}" | sed "/^${DELIM}$/q" | sed '$d'
}

# Print everything except the current segment of the input file.
skip_segment() {
    printf "${1}" | sed "1,/^${DELIM}$/d"
}

# Make a request to the server and get the response.
get_response() {
    local ip=$(printf "${1}" | grep Host: | cut -f2 -d ':' | sed 's/^\ //')
    local port=$(printf "${1}" | grep Host: | cut -f3 -d ':')
    printf "${1}\n\n" | nc -NC ${ip} ${port}
}

# Ignores strings in the response according the the input file. Can only ignore one string per line!
ignore_strings() {
    local ignore
    while IFS='' read -r line
    do
        while IFS='' read -r ignore_me
        do
            if echo "${line}" | grep -q "^${ignore_me}"; then
                ignore="${ignore_me}"
                break
            fi
        done < <(printf "${2}\n")

        if [ -z "${ignore}" ]; then
            echo "${line}"
        else
            echo "$(echo "${line}" | sed "s/^${ignore}.*$/#IGNORED -> ${ignore}#/")"
            ignore=
        fi
    done < <(printf "${1}\n")
}

# Compare the final response string with the segment in the input file.
compare_response_with_expected() {
    if [ "${1}" == "${2}" ]; then
        echo "${COLOR_GREEN}OK${COLOR_RESET}    "
    else
        echo "${COLOR_RED}FAILED${COLOR_RESET}"
    fi
}

# Remove CR from a string.
# HTTP standards states the usage of CRLF, 
# but when comparing with local files, it is better to remove it first.
crlf_to_lf() {
    echo "$(echo "${response}" | tr -d '\r')"
}

# Meta function for running the main function (run) for each file requested.
run_loop() {
    echo -e "\033[1m===== New run at $(date +%r) =====\033[m"
    for file in "${@}"; do
        run "${file}"
        if [ $? -ne 0 ]; then
            return 1
        fi
    done
}

# Main function of the script.
run() {
    local remaining_segments=$(cat "${1}")
    if [ -z "$remaining_segments" ]; then
        return 1
    fi
    local test_name
    local current_segment
    local response
    local verdict

    # Get test name
    test_name=$(get_current_segment "${remaining_segments}")

    # Next segment is request data to send to server
    remaining_segments=$(skip_segment "${remaining_segments}")
    current_segment=$(get_current_segment "${remaining_segments}")
    response=$(get_response "${current_segment}")

    # Next segment is list of strings to ignore
    remaining_segments=$(skip_segment "${remaining_segments}")
    current_segment=$(get_current_segment "${remaining_segments}")
    response=$(ignore_strings "${response}" "${current_segment}")
    response=$(crlf_to_lf "${response}") # Since files are usually stored with only LF on linux, this has to be done when comparing with the local file.

    # Next segment is expected reponse from server
    remaining_segments=$(skip_segment "${remaining_segments}")
    current_segment=$(get_current_segment "${remaining_segments}")
    verdict=$(compare_response_with_expected "${response}" "${current_segment}")
    
    # Print verdict for respective test
    echo -e "${verdict} - ${test_name}"
    if [ "${verdict}" == "${COLOR_RED}FAILED${COLOR_RESET}" ]; then
        echo -n "${response}" > response
        echo -n "${current_segment}" > expected
        echo -e '\033[91mDiagnostic files have been written to "response" and "expected" in current directory.\033[m'
        echo -e '\033[91mThe two version, response (left) versus expected (right), are compared below.\033[m'
        diff <(echo "${response}") <(echo "${current_segment}")
        return 1
    fi
}

if [ ${#} -eq 0 ] || [ "${1}" == "-h" ] || [ "${1}" == "--help" ]; then
    echo "Example usage:"
    echo "    ./request_and_compare [-c] path/to/file [path/to/file2...]"
    echo -e "\nIf you want the tests to run until terminated/interrupted, add the '-c' option before any files."
    exit 0
fi

if [ "${1}" == "-c" ]; then
    while run_loop "${@:2}"; do :; done
else
    run_loop "${@}"
fi
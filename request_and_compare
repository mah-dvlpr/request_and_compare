#!/bin/bash

# Example usage:
# ./request_and_compare path/to/file

# The file that you provide should have the structure
# ################################
# THE REQUEST SENT TO SERVER
# ################################
# HEADERS TO IGNORE IN RESPONSE
# ################################
# LINES IN BODY THAT CONTAIN PATTERN SHOULD BE IGNORED IN RESPONE
# ################################
# THE EXPECTED RESPONSE
# ################################

# Here is an example of what the file might look like:
# GET / HTTP/1.1
# Host: google.com

# ################################
# Date
# Expires
# ################################
# TITLE
# ################################
# HTTP/1.1 301 Moved Permanently
# Location: http://www.google.com/
# Content-Type: text/html; charset=UTF-8
# #IGNORED:Date#
# #IGNORED:Expires#
# Cache-Control: public, max-age=2592000
# Server: gws
# Content-Length: 219
# X-XSS-Protection: 0
# X-Frame-Options: SAMEORIGIN

# <HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
# #IGNORED:TITLE#
# <H1>301 Moved</H1>
# The document has moved
# <A HREF="http://www.google.com/">here</A>.
# </BODY></HTML>

# ################################

set -e # Exit when any command throws an error

INPUT=
DELIM="################################"
TMP=

# Print the current segment of the input file, without any string interpretation.
current_segment() {
    printf "${1}" | sed "/^${DELIM}$/q" | sed '$d'
    return 0
}

# Print everything except the current segment of the input file.
skip_current_segment() {
    printf "${1}" | sed "1,/^${DELIM}$/d"
    return 0
}

# Make a request to the server and get the response.
get_response() {
    local ip="$(printf "${INPUT}" | grep Host: | cut -f2 -d ':' | sed 's/^\ //')"
    local port="$(printf "${INPUT}" | grep Host: | cut -f3 -d ':')"
    printf "${1} $ip $port\n" # HERE
    return 0
}

# Ignores strings in the response according the the input file.
ignore_strings() {
    return 0
}

# Compare the final response string with the segment in the input file.
compare_response_with_expected() {
    return 0
}

INPUT="$(cat ${1})"
TMP=$(get_response "$(current_segment "${INPUT}")")
printf "$TMP\n\n"


# while IFS= read -r line
# do

#     echo "$line"
# done < "${1}"
#!/bin/bash

DELIM="################################"
COLOR_RESET="\033[0m"
COLOR_GREEN="\033[1;92m"
COLOR_RED="\033[1;91m"

# Print the current segment of the input file, without any string interpretation.
get_current_segment() {
    printf "${1}" | sed "/^${DELIM}$/q" | sed '$d'
}

# Print everything except the current segment of the input file.
skip_segment() {
    printf "${1}" | sed "1,/^${DELIM}$/d"
}

# Make a request to the server and get the response.
get_response() {
    local ip=$(printf "${1}" | grep Host: | cut -f2 -d ':' | sed 's/^\ //')
    local port=$(printf "${1}" | grep Host: | cut -f3 -d ':')
    printf "${1}\n\n" | nc -NC ${ip} ${port}
}

# Ignores strings in the response according the the input file. Can only ignore one string per line!
ignore_strings() {
    local ignore
    while IFS='' read -r line
    do
        while IFS='' read -r ignore_me
        do
            if echo "${line}" | grep -q "^${ignore_me}"; then
                ignore="${ignore_me}"
                break
            fi
        done < <(printf "${2}\n")

        if [ -z "${ignore}" ]; then
            echo "${line}"
        else
            echo "$(echo "${line}" | sed "s/^${ignore}.*$/#IGNORED -> ${ignore}#/")"
            ignore=
        fi
    done < <(printf "${1}\n")
}

# Compare the final response string with the segment in the input file.
compare_response_with_expected() {
    if [ "${1}" == "${2}" ]; then
        echo "${COLOR_GREEN}OK${COLOR_RESET}    "
    else
        echo "${COLOR_RED}FAILED${COLOR_RESET}"
    fi
}

# Remove CR from a string.
# HTTP standards states the usage of CRLF, 
# but when comparing with local files, it is better to remove it first.
crlf_to_lf() {
    echo "$(echo "${response}" | tr -d '\r')"
}

# Generate the expected response by for later comparison with a response from server and add it to input file.
generate_expected_response() {
    local remaining_segments=$(cat "${1}" 2>/dev/null)
    if [ -z "${remaining_segments}" ]; then
        echo -e "NAME_OF_THE_TEST
${DELIM}
THE_REQUEST_SENT_TO_SERVER
${DELIM}
STRINGS_TO_IGNORE_IN_RESPONSE
${DELIM}
THE_EXPECTED_RESPONSE
${DELIM}" > "${1}"
        echo -e "${COLOR_RED}Generated an empty file. You have to fill this in according to the -h|--help section!${COLOR_RESET}"
        return 0
    fi
    local current_segment
    local response

    # Next segment is request data to send to server
    remaining_segments=$(skip_segment "${remaining_segments}")
    current_segment=$(get_current_segment "${remaining_segments}")
    response=$(get_response "${current_segment}")
    if [ -z "${response}" ]; then
        echo -e "${COLOR_RED}Server failed to respond.${COLOR_RESET}"
        return 1
    fi

    # Next segment is list of strings to ignore
    remaining_segments=$(skip_segment "${remaining_segments}")
    if [ "$(echo "${remaining_segments}" | head -n 1)" != "${DELIM}" ]; then # If the ignore strings segment is empty but not containing a newline...
        current_segment=$(get_current_segment "${remaining_segments}")
        response=$(ignore_strings "${response}" "${current_segment}")
    else
        remaining_segments=$(echo "${remaining_segments}" | sed "1s/^${DELIM}$/ignore_me\n${DELIM}/") # Skip the delimiter by removing it so that next 'skip_segment' works.
    fi
    response=$(crlf_to_lf "${response}") # Since files are usually stored with only LF on linux, this has to be done when comparing with the local file.

    # Check that there isn't an expected response segment already
    if [ "$(tail -n 2 "${1}" | head -n 1)" != "${DELIM}" ]; then
        echo -e "\033[1mProvided files is either malformed or already contains an expected response segment.
If you want to generate a new one, please remove this segment as in the example below:\033[m
GET_TEST
################################
GET / HTTP/1.1
Host: localhost:8080
Connection: close
################################
Date
Last-Modified
ETag
################################
################################"
        return 1
    fi

    # Append to expected result to file
    sed -i '$d' "${1}"
    echo "${response}" >> "${1}"
    echo "${DELIM}" >> "${1}"
    echo -e "Request response generated and added to file!"
}

# Main function of the script.
run() {
    local remaining_segments=$(cat "${1}")
    if [ -z "$remaining_segments" ]; then
        return 1
    fi
    local test_name
    local current_segment
    local response
    local verdict

    # Get test name
    test_name=$(get_current_segment "${remaining_segments}")

    # Next segment is request data to send to server
    remaining_segments=$(skip_segment "${remaining_segments}")
    current_segment=$(get_current_segment "${remaining_segments}")
    response=$(get_response "${current_segment}")
    if [ -z "${response}" ]; then
        echo -e "${COLOR_RED}FAILED${COLOR_RESET} - ${test_name}"
        echo -e "${COLOR_RED}Server failed to respond.${COLOR_RESET}"
        return 1
    fi

    # Next segment is list of strings to ignore
    remaining_segments=$(skip_segment "${remaining_segments}")
    if [ "$(echo "${remaining_segments}" | head -n 1)" != "${DELIM}" ]; then # If the ignore strings segment is empty but not containing a newline...
        current_segment=$(get_current_segment "${remaining_segments}")
        response=$(ignore_strings "${response}" "${current_segment}")
    else
        remaining_segments=$(echo "${remaining_segments}" | sed "1s/^${DELIM}$/ignore_me\n${DELIM}/") # Skip the delimiter by removing it so that next 'skip_segment' works.
    fi
    response=$(crlf_to_lf "${response}") # Since files are usually stored with only LF on linux, this has to be done when comparing with the local file.

    # Next segment is expected reponse from server
    remaining_segments=$(skip_segment "${remaining_segments}")
    current_segment=$(get_current_segment "${remaining_segments}")
    verdict=$(compare_response_with_expected "${response}" "${current_segment}")
    
    # Print verdict for respective test
    echo -e "${verdict} - ${test_name}"
    if [ "${verdict}" == "${COLOR_RED}FAILED${COLOR_RESET}" ]; then
        echo -n "${response}" > response
        echo -n "${current_segment}" > expected
        echo -e '\033[91mDiagnostic files have been written to "response" and "expected" in current directory.\033[m'
        echo -e '\033[91mThe two version, response (left) versus expected (right), are compared below.\033[m'
        diff <(echo "${response}") <(echo "${current_segment}")
        return 1
    fi
}

# Meta function for running the main function (run) for each file requested.
run_loop() {
    echo -e "\033[1m===== New run at $(date +%r) =====\033[m"
    for file in "${@}"; do
        if ! run "${file}"; then
            return 1
        fi
    done
}

if [ ${#} -eq 0 ] || [ "${1}" == "-h" ] || [ "${1}" == "--help" ]; then
    echo "Example usage:"
    echo "    ./request_and_compare [-c|-g] path/to/file [path/to/file2...]"
    echo -e "\nIf you want the tests to run until terminated/interrupted, add the '-c' option before any files."
    echo -e "\nIt can be hard to write the expected result by hand. If you have a working server which delivers the correct response, you can generate and append its response to an existing file (which misses the expected resonse portion). Add the '-g' option before adding a single file to generate this string and append it to given file."
    echo "If the file provided is non-existent or empty, when applying the '-g' option, then the script will simply generate a file with the required structure. No actual 'real' data is written."
    
    echo -e "\n\033[1mThe file that you provide must have the following structure:\033[m
NAME_OF_THE_TEST
################################
THE_REQUEST_SENT_TO_SERVER
################################
STRINGS_TO_IGNORE_IN_RESPONSE
################################
THE_EXPECTED_RESPONSE
################################

\033[1mExample of the generated file when an empty file is provided (with the '-g' option i.e. './request_and_compare -g empty_file'):\033[m
################################
################################
################################
################################

\033[1mExample of what a file might look like before generating the expected response with the '-g' option:\033[m
GET_TEST
################################
GET / HTTP/1.1
Host: localhost:8080
Connection: close
################################
Date
Last-Modified
ETag
################################
################################

\033[1mExample of what the final file might look like (and what is generated with the '-g' option i.e. './request_and_compare -g request_file_missing_expected_result_segment'). :\033[m
GET_TEST
################################
GET / HTTP/1.1
Host: localhost:8080
Connection: close
################################
Date
Last-Modified
ETag
################################
HTTP/1.1 200 OK
Content-Type: text/html
Accept-Ranges: bytes
#IGNORED -> ETag#
#IGNORED -> Last-Modified#
Content-Length: 93
Connection: close
#IGNORED -> Date#
Server: lighttpd/1.4.55

<html>
    <body>
        <h1>
            Index test page!
        </h1>
    </body>
</html>
################################"

    exit 0
fi

if [ "${1}" == "-g" ]; then
    if ! generate_expected_response "${2}"; then
        echo -e "${COLOR_RED}Failed to generate request file. Either bad input file or no response from server!${COLOR_RESET}"
        exit 1
    fi
    exit 0
fi

if [ "${1}" == "-c" ]; then
    while run_loop "${@:2}"; do :; done
else
    run_loop "${@}"
fi
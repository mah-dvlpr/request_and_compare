#!/bin/bash

# Example usage:
# ./request_and_compare path/to/file

# The file that you provide should have the structure
# ################################
# THE REQUEST SENT TO SERVER
# ################################
# HEADERS TO IGNORE IN RESPONSE
# ################################
# LINES IN BODY THAT CONTAIN PATTERN SHOULD BE IGNORED IN RESPONE (CURRENTLY NOT IMPLEMENTED/USED!!!)
# ################################
# THE EXPECTED RESPONSE
# ################################

# Here is an example of what the file might look like:
# GET / HTTP/1.1
# Host: google.com

# ################################
# Date
# Expires
# ################################
# HTTP/1.1 301 Moved Permanently
# Location: http://www.google.com/
# Content-Type: text/html; charset=UTF-8
# #IGNORED:Date#
# #IGNORED:Expires#
# Cache-Control: public, max-age=2592000
# Server: gws
# Content-Length: 219
# X-XSS-Protection: 0
# X-Frame-Options: SAMEORIGIN

# <HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
# #IGNORED:TITLE#
# <H1>301 Moved</H1>
# The document has moved
# <A HREF="http://www.google.com/">here</A>.
# </BODY></HTML>

# ################################

set -e # Exit when any command throws an error

INPUT="$(cat ${1})"
DELIM="################################"

# Print the current segment of the input file, without any string interpretation.
get_current_segment() {
    printf "${1}" | sed "/^${DELIM}$/q" | sed '$d'
    return 0
}

# Print everything except the current segment of the input file.
skip_segment() {
    printf "${1}" | sed "1,/^${DELIM}$/d"
    return 0
}

# Make a request to the server and get the response.
get_response() {
    local ip=$(printf "${1}" | grep Host: | cut -f2 -d ':' | sed 's/^\ //')
    local port=$(printf "${1}" | grep Host: | cut -f3 -d ':')
    printf "${1}\n\n" | nc -NC ${ip} ${port}
    return 0
}

# Ignores strings in the response according the the input file. Can only ignore one string per line!
ignore_strings() {
    local ignore
    while IFS='' read -r line
    do
        while IFS='' read -r ignore_me
        do
            if echo "${line}" | grep -q "^${ignore_me}"; then
                ignore="${ignore_me}"
                break
            fi
        done < <(printf "${2}\n")
        if [ -z "${ignore}" ]; then
            echo "${line}"
        else
            echo "$(echo "${line}" | sed "s/^${ignore}.*$/#IGNORED -> ${ignore}#/")"
            ignore=
        fi
    done < <(printf "${1}\n")
    return 0
}

# Compare the final response string with the segment in the input file.
compare_response_with_expected() {
    local lf=$(echo "${1}" | tr -d '\r') # Have to remove CR from "windows version" from server in order to compare with "linux version"-file.
    if [ "${lf}" == "${2}" ]; then
        printf 'OK'
    else
        printf 'FAILED'
    fi
    return 0
}

run() {
    local remaining_segments="${INPUT}"
    local current_segment=$(get_current_segment "${remaining_segments}")
    local response=$(get_response "${current_segment}")
    local verdict=''

    # Next segment is list of strings to ignore
    remaining_segments=$(skip_segment "${remaining_segments}")
    current_segment=$(get_current_segment "${remaining_segments}")
    response=$(ignore_strings "${response}" "${current_segment}")

    # Next segment is expected reponse from server
    remaining_segments=$(skip_segment "${remaining_segments}")
    current_segment=$(get_current_segment "${remaining_segments}")
    verdict=$(compare_response_with_expected "${response}" "${current_segment}")

    echo "${verdict}"
}

run